//Задача №1. Генерация произвольных массивов и адаптирование кода под существующую ситуацию

let count = 42; // Количество элементов, которые нужно сгенерировать в массиве
let n = -3;  // Нижняя граница диапазона (может быть больше m — это учтено ниже)
let m = -10;  // Верхняя граница диапазона

let arr = [];  // Инициализация пустого массива для хранения случайных чисел

let min = Math.min(n, m); // Вычисление минимального значения из n и m
let max = Math.max(n, m); // Вычисление максимального значения из n и m
let range = Math.abs(max - min);  // Длина диапазона (включительно), гарантирует положительное значение

for(let i = 0; i < count; i++){  // Цикл, который выполнится count раз
let j = Math.floor((Math.random() * (range + 1)) + min);
// Генерация случайного целого числа от min до max включительно:
// Math.random() → [0, 1), умножаем на (range + 1) → [0, range + 1). ПОТОМУ ЧТО Math.random() даёт число от 0 (включительно) до 1 НО!(не включительно)
//(range + 1)  → чтобы включить верхнюю границу max! 
//Почему +min?
//Потому что Math.random() всегда стартует с 0. Чтобы сдвинуть диапазон от [0, range] к [min, max], мы просто прибавляем min.
// Math.floor(...) → округление вниз до целого
// + min → сдвиг диапазона к нужному интервалу
arr.push(j); // Добавление сгенерированного числа в массив  
}

console.log(arr); // Вывод готового массива в консоль



//Задача №2. Перемешивание массива чисел с помощью алгоритма Fisher — Yates

// Объявляем переменную count2 и присваиваем ей значение 5 — это количество элементов в массиве.
let count2 = 5;
// Создаём пустой массив, в который позже добавим числа от 1 до count2.
let array = [];

for(let i = 1; i <= count2; i++){
array.push(i);
// Цикл от 1 до 5 включительно:
// На каждой итерации добавляем текущее значение i в массив.
// В итоге array будет: [1, 2, 3, 4, 5]
}

for(let i = array.length - 1; i > 0; i--){
// Запускаем цикл от последнего индекса массива (4) к первому (1).
// Это реализация алгоритма Фишера–Йетса для равномерного перемешивания.
let j = Math.floor(Math.random() * (i + 1));
// Генерируем случайный индекс j от 0 до i включительно.
// Math.random() даёт число от 0 до 1 (не включая 1),
// умножаем на (i + 1), затем округляем вниз до целого.
let temp = array[i];
// Сохраняем значение array[i] во временную переменную temp,
// чтобы не потерять его при обмене.
array[i] = array[j];
// Присваиваем элементу с индексом i значение элемента с индексом j.
array[j] = temp;
// Завершаем обмен: элемент с индексом j получает значение из temp,
// то есть исходное значение array[i].
}

console.log(array);

//Задача №3. Перемешивание массива чисел с помощью алгоритма Fisher — Yates и поиск индекса нужного элемента в массиве.

let count3 = 5;
let array2 = [];

for(let i = 1; i <= count3; i++){
array2.push(i);
}

for(let i = array2.length - 1; i > 0; i--){
let j = Math.floor(Math.random() * (i + 1));
let temp = array2[i];
array2[i] = array2[j];
array2[j] = temp;
}

console.log('Задача 3',  array2);
// Задаём число, которое нужно найти в массиве.
let c = 2;
// Флаг, который отслеживает, найден ли элемент.
// Изначально false, станет true при нахождении.
let found = false;

for(let i = 0; i < array2.length; i++){
// Перебираем массив по индексам.
// Если текущий элемент равен c, выводим его индекс.
// Устанавливаем флаг found = true и прерываем цикл с break.
if(array2[i] === c){
console.log('Индекс элемента: ', i);
found = true;
break;
}
} 
// Если этот блок находится внутри цикла.
// Это значит, что сообщение "Элемент не найден" будет выводиться на каждой итерации,
// пока не найден нужный элемент — даже если он есть в массиве.
// ✅ Решение: перенести `if (!found)` **вне** цикла, чтобы сообщение выводилось только один раз.
if(!found){
console.log('Данный элемент не найден');
}



//Задача №3. Вариант 2. 

let array3 = [3, 1, 5, 2, 4]; 
// Задаём переменную d — это значение, которое мы хотим найти в массиве.
let d = 3;
// Переменная index будет хранить индекс найденного элемента.
// Изначально -1 означает, что элемент ещё не найден.
let index = -1;

for (let i = 0; i < array3.length; i++) { //Оба выражения эквивалентны: i < array3.length // проходит от 0 до 4; i <= array3.length - 1 // тоже от 0 до 4
  if (array3[i] === d) {
    index = i;
    console.log(array3);
    console.log(`d = ${d}, индекс элемента = ${index}`);
    break;
  }
}
// Цикл перебирает массив от 0 до последнего индекса (array3.length - 1), используя условие i < array3.length(«пока индекс меньше длины»)
// На каждой итерации сравниваем текущий элемент array3[i] с искомым значением d.
// Если найдено совпадение:
// сохраняем индекс в переменную index
// выводим весь массив
// выводим сообщение с найденным значением и его индексом
// прерываем цикл с помощью break, чтобы не продолжать поиск

if (index === -1) {
  console.log(array3);
  console.log(`d = ${d}, элемент не найден`);
}

// После завершения цикла проверяем, был ли элемент найден.
// Если index остался равным -1, значит, совпадений не было.
// Выводим массив и сообщение о том, что элемент не найден.



// Задача №4. Обработка массивов одним циклом. Объединение двух массивов

let arr1 = [2, 2, 17, 21, 45, 12, 54, 31, 53];
let arr2 = [12, 44, 23, 5];

for(let i = 0; i < arr2.length; i++){
// Цикл перебирает массив arr2 по индексам от 0 до arr2.length - 1.
// На каждой итерации переменная i указывает на текущий элемент arr2.
arr1.push(arr2[i]);
// Добавляем текущий элемент из arr2 в конец массива arr1.
// Метод push изменяет arr1 напрямую, не создавая новый массив.
}
console.log(arr1);
// Выводим текущую версию массива arr1 после добавления очередного элемента.
// Это позволяет видеть, как массив растёт шаг за шагом.



// Задача №4. Вариант 2. Обработка массивов одним циклом. Сложение элементов массива

let arr4 = [2, 2, 17, 21, 45, 12, 54, 31, 53];
// Исходный массив №1 — содержит числовые значения, с которыми будем работать.
let arr5 = [12, 44, 23, 5, 0];
// Исходный массив №2 — будем складывать его элементы с соответствующими элементами из arr4.
// Обрати внимание: он короче, чем arr4.

let result = [];
// Создаём пустой массив, в который будем записывать суммы элементов с одинаковыми индексами.

for (let i = 0; i < arr4.length && i < arr5.length; i++) {
// Цикл начинается с i = 0 и продолжается, пока i меньше длины обоих массивов.
// Это гарантирует, что мы не выйдем за границы ни одного из них.
result.push(arr4[i] + arr5[i]);
// На каждой итерации берём элемент из arr4 и arr5 с индексом i,
// складываем их и добавляем результат в массив result.
// Индекс 0: 2 + 12 = 14
// Индекс 1: 2 + 44 = 46
// Индекс 2: 17 + 23 = 40
// Индекс 3: 21 + 5 = 26
// Индекс 4: 45 + 0 = 45
}

console.log(result);
// Выводим итоговый массив в консоль.
// Он содержит суммы парных элементов из arr4 и arr5.



//Задача 4. Вариант 3. Обработка массивов одним циклом. Объединение двух массивов, чередуя их элементы

let arr6 = [2, 2, 17, 21, 45, 12, 54, 31, 53];
// Первый массив — содержит 9 элементов.
let arr7 = [12, 44, 23, 5];
// Второй массив — содержит 4 элемента. Он короче, и это важно для логики цикла

let result2 = [];
// Создаём пустой массив, куда будем поочерёдно добавлять элементы из arr6 и arr7.

for (let i = 0; i < arr6.length && i < arr7.length; i++) {
// Цикл идёт по индексам, пока i меньше длины обоих массивов.
// Это защищает от выхода за границы более короткого массива (arr7).
result2.push(arr6[i], arr7[i]);
// На каждой итерации добавляем два элемента: сначала из arr6, потом из arr7.
// Получается чередование: arr6[0], arr7[0], arr6[1], arr7[1], ...
}

console.log(result2);
// Индекс 0: 2, 12
// Индекс 1: 2, 44
// Индекс 2: 17, 23
// Индекс 3: 21, 5



//Задача 4. Вариант 4. Обработка массивов одним циклом. Объединение двух массивов, чередуя их элементы с добавлением остатка из более длинного массива

let arr8 = [2, 2, 17, 21, 45, 12, 54, 31, 53];
let arr9 = [12, 44, 23, 5];

let result3 = [];

for (let i = 0; // начинаем с нуля
i < Math.max(arr8.length, arr9.length); // условие: пока i меньше максимальной длины
i++){  // увеличиваем i на каждом шаге
//«Для каждой итерации, начиная с i = 0, продолжай цикл, пока i меньше максимальной длины между arr8 и arr9. На каждом шаге увеличивай i на 1.»
// Цикл идёт до максимальной длины из двух массивов, чтобы охватить все элементы.
if(i < arr8.length) result3.push(arr8[i]);
// Если текущий индекс i существует в arr8 — добавляем элемент из arr8.
if(i < arr9.length) result3.push(arr9[i]);
// Если текущий индекс i существует в arr9 — добавляем элемент из arr9.
// Таким образом, элементы чередуются, и остаток из более длинного массива тоже добавляется
}

console.log(result3);
