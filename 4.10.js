//Задача №1. Генерация произвольных массивов и адаптирование кода под существующую ситуацию

let count = 42; // Количество элементов, которые нужно сгенерировать в массиве
let n = -3;  // Нижняя граница диапазона (может быть больше m — это учтено ниже)
let m = -10;  // Верхняя граница диапазона

let arr = [];  // Инициализация пустого массива для хранения случайных чисел

let min = Math.min(n, m); // Вычисление минимального значения из n и m
let max = Math.max(n, m); // Вычисление максимального значения из n и m
let range = Math.abs(max - min);  // Длина диапазона (включительно), гарантирует положительное значение

for(let i = 0; i < count; i++){  // Цикл, который выполнится count раз
let j = Math.floor((Math.random() * (range + 1)) + min);
// Генерация случайного целого числа от min до max включительно:
// Math.random() → [0, 1), умножаем на (range + 1) → [0, range + 1). ПОТОМУ ЧТО Math.random() даёт число от 0 (включительно) до 1 НО!(не включительно)
//(range + 1)  → чтобы включить верхнюю границу max! 
//Почему +min?
//Потому что Math.random() всегда стартует с 0. Чтобы сдвинуть диапазон от [0, range] к [min, max], мы просто прибавляем min.
// Math.floor(...) → округление вниз до целого
// + min → сдвиг диапазона к нужному интервалу
arr.push(j); // Добавление сгенерированного числа в массив  
}

console.log(arr); // Вывод готового массива в консоль



//Задача №2. Перемешивание массива чисел с помощью алгоритма Fisher — Yates

// Объявляем переменную count2 и присваиваем ей значение 5 — это количество элементов в массиве.
let count2 = 5;
// Создаём пустой массив, в который позже добавим числа от 1 до count2.
let array = [];

for(let i = 1; i <= count2; i++){
array.push(i);
// Цикл от 1 до 5 включительно:
// На каждой итерации добавляем текущее значение i в массив.
// В итоге array будет: [1, 2, 3, 4, 5]
}

for(let i = array.length - 1; i > 0; i--){
// Запускаем цикл от последнего индекса массива (4) к первому (1).
// Это реализация алгоритма Фишера–Йетса для равномерного перемешивания.
let j = Math.floor(Math.random() * (i + 1));
// Генерируем случайный индекс j от 0 до i включительно.
// Math.random() даёт число от 0 до 1 (не включая 1),
// умножаем на (i + 1), затем округляем вниз до целого.
let temp = array[i];
// Сохраняем значение array[i] во временную переменную temp,
// чтобы не потерять его при обмене.
array[i] = array[j];
// Присваиваем элементу с индексом i значение элемента с индексом j.
array[j] = temp;
// Завершаем обмен: элемент с индексом j получает значение из temp,
// то есть исходное значение array[i].
}

console.log(array);

//Задача №3. Перемешивание массива чисел с помощью алгоритма Fisher — Yates и поиск индекса нужного элемента в массиве.

let count3 = 5;
let array2 = [];

for(let i = 1; i <= count3; i++){
array2.push(i);
}

for(let i = array2.length - 1; i > 0; i--){
let j = Math.floor(Math.random() * (i + 1));
let temp = array2[i];
array2[i] = array2[j];
array2[j] = temp;
}

console.log('Задача 3',  array2);
// Задаём число, которое нужно найти в массиве.
let c = 2;
// Флаг, который отслеживает, найден ли элемент.
// Изначально false, станет true при нахождении.
let found = false;

for(let i = 0; i < array2.length; i++){
// Перебираем массив по индексам.
// Если текущий элемент равен c, выводим его индекс.
// Устанавливаем флаг found = true и прерываем цикл с break.
if(array2[i] === c){
console.log('Индекс элемента: ', i);
found = true;
break;
}
} 
// Если этот блок находится внутри цикла.
// Это значит, что сообщение "Элемент не найден" будет выводиться на каждой итерации,
// пока не найден нужный элемент — даже если он есть в массиве.
// ✅ Решение: перенести `if (!found)` **вне** цикла, чтобы сообщение выводилось только один раз.
if(!found){
console.log('Данный элемент не найден');
}



//Задача №3. Вариант 2. 

let array3 = [3, 1, 5, 2, 4]; 
// Задаём переменную d — это значение, которое мы хотим найти в массиве.
let d = 3;
// Переменная index будет хранить индекс найденного элемента.
// Изначально -1 означает, что элемент ещё не найден.
let index = -1;

for (let i = 0; i < array3.length; i++) { //Оба выражения эквивалентны: i < array3.length // проходит от 0 до 4; i <= array3.length - 1 // тоже от 0 до 4
  if (array3[i] === d) {
    index = i;
    console.log(array3);
    console.log(`d = ${d}, индекс элемента = ${index}`);
    break;
  }
}
// Цикл перебирает массив от 0 до последнего индекса (array3.length - 1), используя условие i < array3.length(«пока индекс меньше длины»)
// На каждой итерации сравниваем текущий элемент array3[i] с искомым значением d.
// Если найдено совпадение:
// сохраняем индекс в переменную index
// выводим весь массив
// выводим сообщение с найденным значением и его индексом
// прерываем цикл с помощью break, чтобы не продолжать поиск

if (index === -1) {
  console.log(array3);
  console.log(`d = ${d}, элемент не найден`);
}

// После завершения цикла проверяем, был ли элемент найден.
// Если index остался равным -1, значит, совпадений не было.
// Выводим массив и сообщение о том, что элемент не найден.


//Задача 4

let arr1 = [2, 2, 17, 21, 45, 12, 54, 31, 53];

let arr2 = [12, 44, 23, 5];

for (i = 0; i < arr2[i]; i++) {
        arr1.push(arr2[i]);
}

console.log(arr1);


//Задача. Сложение элементов массива

let arr4 = [2, 2, 17, 21, 45, 12, 54, 31, 53];

let arr5 = [12, 44, 23, 5];

let result1 = [];

for (i = 0; arr4[i] && arr5[i]; i++) {
    result1.push(arr4[i] + arr5[i]);
}

console.log(result1);


//Задача. Объединение двух массивов, чередуя их элементы (не закончена)

let arr6 = [2, 2, 17, 21, 45, 12, 54, 31, 53];

let arr7 = [12, 44, 23, 5];

let result2 = [];

for (i = 0; arr6[i] + arr7[i]; i++) {
    result2.push(arr6[i], arr7[i]);
}

console.log(result2);


//Задача. Объединение двух массивов, чередуя их элементы (не закончена)

// let arr1 = [2, 2, 17, 21, 45, 12, 54, 31, 53];

// let arr2 = [12, 44, 23, 5];

// let result = [];

// for (i = 0; i < arr1[i] || i < arr2[i]; i++) {
//     result.push(arr1[i]);
//     result.push(arr2[i]);
// }

// console.log(result);